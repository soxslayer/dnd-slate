#include <stdexcept>
#include <string>
#include <unistd.h>

#include <glibmm.h>
#include <sigc++/sigc++.h>
#include <boost/bind.hpp>

#include "dnd_server.h"
#include "dnd_messages.h"

using namespace std;
using namespace boost::asio;

DnDServerImpl::DnDServerImpl (io_service& io_service,
                              short port)
  : Engine::Server (io_service, port),
    _io_service (io_service)
{
  start ();

  _network_worker_thread = Glib::Thread::create (
    sigc::mem_fun (this, &DnDServerImpl::network_thread), true);
}

DnDServerImpl::~DnDServerImpl ()
{
  _io_service.stop ();
  _network_worker_thread->join ();
}

Engine::Client* DnDServerImpl::create_client (io_service& io_service)
{
  Engine::Client* client = new Engine::Client (io_service);

  client->error_handler = boost::bind (&DnDServerImpl::client_error_handler,
                                       this, client, _1);
  client->message_handler = boost::bind (
    &DnDServerImpl::client_message_handler, this, client, _1, _2);

  return client;
}

void DnDServerImpl::client_error_handler (Engine::Client* client,
                                          const boost::system::error_code& ec)
{
}

void DnDServerImpl::client_message_handler (Engine::Client* client,
                                            void* message,
                                            size_t size)
{
  DnDMessageHeader* header = reinterpret_cast<DnDMessageHeader*> (message);

  switch (header->type) {
    case DND_USER_ADD_REQ: {
      DnDUserAddReq* msg = reinterpret_cast<DnDUserAddReq*> (header);
      string name;
      Engine::UuidManager::Uuid uuid = _uuid_manager.get_uuid ();

      /* The first player to connect is the DM */
      if (_client_id_map.empty ()) {
        name = "[DM] ";
        _dm_uuid = uuid;
      }

      msg->name[size - 1] = 0;
      name += msg->name;

      _client_id_map.insert (pair<Engine::UuidManager::Uuid, ClientId> (
        uuid, ClientId (client, uuid, name)));

      /* The extra bytes is for the NULL terminator */
      size_t name_len = name.size ();
      size_t msg_size = offsetof (DnDUserAddResp, name) + name_len + 1;
      char* buff = new char[msg_size];
      DnDUserAddResp* resp = reinterpret_cast<DnDUserAddResp*> (buff);

      resp->header.type = DND_USER_ADD_RESP;
      resp->uuid = uuid;
      memcpy (&resp->name, name.c_str (), name_len);
      resp->name[name_len] = 0;

      send_to_all (resp, msg_size);

      map<Engine::UuidManager::Uuid, ClientId>::iterator beg
        =  _client_id_map.begin ();
      map<Engine::UuidManager::Uuid, ClientId>::iterator end
        =  _client_id_map.end ();

      /* Inform the new user of all existing players */
      size_t buff_size = msg_size;
      for (; beg != end; ++beg) {
        if (beg->second.uuid == uuid)
          continue;

        name_len = beg->second.name.size ();
        msg_size = offsetof (DnDUserAddResp, name) + name_len + 1;

        if (!buff || msg_size > buff_size) {
          delete [] resp;
          buff = new char[msg_size];
          buff_size = msg_size;
        }

        resp = reinterpret_cast<DnDUserAddResp*> (buff);

        resp->header.type = DND_USER_ADD_RESP;
        resp->uuid = beg->second.uuid;
        memcpy (&resp->name, beg->second.name.c_str (), name_len);
        resp->name[name_len] = 0;

        client->send_message (resp, msg_size);
      }

      delete [] buff;

      break;
    }
  }
}

void DnDServerImpl::send_to_all (void* message,
                                 size_t size)
{
  map<Engine::UuidManager::Uuid, ClientId>::iterator beg
    = _client_id_map.begin ();
  map<Engine::UuidManager::Uuid, ClientId>::iterator end
    = _client_id_map.end ();

  for (; beg != end; ++beg) {
    Engine::Client* client = beg->second.client;
    client->send_message (message, size);
  }
}

void DnDServerImpl::send_to_all_except (Engine::Client* client,
                                        void* message,
                                        size_t size)
{
  map<Engine::UuidManager::Uuid, ClientId>::iterator beg
    = _client_id_map.begin ();
  map<Engine::UuidManager::Uuid, ClientId>::iterator end
    = _client_id_map.end ();

  for (; beg != end; ++beg) {
    Engine::Client* c = beg->second.client;

    if (c == client)
      continue;

    c->send_message (message, size);
  }
}

void DnDServerImpl::network_thread ()
{
  _io_service.run ();
}



DnDServer::DnDServer (short port)
  : _io_service (),
    _server (_io_service, port)
{
}
