#include <string>
#include <cstring>
#include <cstddef>

#include <sigc++/sigc++.h>
#include <boost/bind.hpp>

#include "dnd_client.h"

using namespace std;

DnDClient::DnDClient (string& addr,
                      short port)
  : _io_service (),
    _client (addr, port, _io_service)
{
  _client.error_handler = boost::bind (&DnDClient::bg_error_handler, this, _1);
  _client.message_handler = boost::bind (&DnDClient::bg_message_handler, this,
    _1, _2);

  _dispatcher.connect (sigc::mem_fun (this, &DnDClient::dispatch_handler));

  _client.start ();

  _network_worker_thread = Glib::Thread::create (
    sigc::mem_fun (this, &DnDClient::network_thread), true);
}

DnDClient::~DnDClient ()
{
  _io_service.stop ();
  _network_worker_thread->join ();
}

void DnDClient::user_add_req (const string& name)
{
  DnDUserAddReq* msg;
  size_t name_len = name.size ();
  size_t msg_len = offsetof (DnDUserAddReq, name) + name_len + 1;

  msg = new DnDUserAddReq;

  msg->header.type = DND_USER_ADD_REQ;
  memcpy (&msg->name, name.c_str (), name_len);
  msg->name[name.size ()] = 0;

  _client.send_message (msg, msg_len);

  delete msg;
}

void DnDClient::dispatch_handler ()
{
  _queue_mutex.lock ();

  pair<void*, size_t> msg_pair = _queue.back ();
  _queue.pop_back ();

  _queue_mutex.unlock ();

  DnDMessageHeader* header
    = reinterpret_cast<DnDMessageHeader*> (msg_pair.first);
  size_t size = msg_pair.second;

  /* A NULL pointer indicates an error from the client */
  if (!header) {
    signal_disconnect ();
    return;
  }

  switch (header->type) {
    case DND_USER_ADD_RESP: {
      DnDUserAddResp* msg = reinterpret_cast<DnDUserAddResp*> (header);

      msg->name[size - 1] = 0;

      string name (msg->name);

      signal_user_add_resp (msg->uuid, name);

      break;
    }
  }
}

void DnDClient::network_thread ()
{
  _io_service.run ();
}

void DnDClient::signal_gui (void* message,
                            size_t size)
{
  _queue_mutex.lock ();

  _queue.push_front (pair<void*, size_t> (message, size));

  _queue_mutex.unlock ();

  _dispatcher.emit ();
}

void DnDClient::bg_error_handler (const boost::system::error_code& ec)
{
  signal_gui (0, 0);
}

void DnDClient::bg_message_handler (void* message,
                                    size_t size)
{
  signal_gui (message, size);
}
